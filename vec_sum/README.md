# LuNA. Покомпонентное сложение векторов
Задача покомпонентного сложениния векторов возникает повсеместно. Хоть ее и достаточно просто осознать, задачу можно так же рассматривать как отличный пример для практики в освоении нового языка программирования.

Передо мной встала задача просуммировать два вектора на языке LuNA. 

Чтобы понять, с чем мы имеем дело, рассмотрим сумму векторов из трех элементов.
```math
\begin{pmatrix}
    a_1 \\
    a_2 \\
    a_3
\end{pmatrix} + 
\begin{pmatrix}
    b_1 \\
    b_2 \\
    b_3
\end{pmatrix}
```

Для начала зададим векторы a и b. Переменные задаются как фрагменты данных. Вообще нельзя объявить фрагменты данных несколько раз. Они должны быть перечислены через запятую в начале программы.
```
sub main()
{
    df a, b;
}
```

Теперь рассмотрим два подхода к инициализаии и, следовательно, суммированию векторов.

**Инициализация без явного выделения памяти**
LuNA позволяет обращаться к фрагментам данных через оператор квадратных скобок.

test.fa
```
import c_init(name, int) as init;

sub initialize(name vector, int value, int len) 
{
    for i=1..len {
        init(vector[i], value);
    }
}

sub main() 
{
    df a, b;
    cf a: initialize(a, 10, 3);
    cf b: initialize(b, 5, 3);
}
```

ucodes.cpp
```
#include "ucenv.h"
#include <cstdio>

extern "C" {

void c_init(OutputDF &df, int val) { df.setValue(val); }
```

В программе мы инициализируем каждый элемент вектора a десяткой и b пяторкой. 

Также входной аргумент `name` в функциях озночает `OutputDF`. То есть фрагмент данных, который функция должна изменить. Если для изменения некоторого фрагмента данных необходимо извлекать информацию из других фрагментов, они будут типом `InputDF` и обозначаться в LuNA как `value`.

Еще можно обратить внимание на `cf a:`, что обозначает применение некоторого фрагмента кода к существующим данным. 

Осталось просуммировать векторы. Первой мыслью было передать весь вектор `a` в си-функцию и просуммировать его уже там. К сожалению, так просто сделать не получится. Мы инициализировали каждый элемент вектора `a` отдельно. По сути, их ничего между собой не связывает. Элементы `a1`, `a2` и `a3` не лежат в памяти в строгом порядке, и мы не сможем обращаться к ним с помощью итерации в си-функции. 

Решение заключается в том, чтобы итерироваться по элементам в LuNA, а суммировать уже в Си.

```
import c_sum_elements(name, int) as sum_elements;

sub sum_vectors(name a, name b, name result, int len) 
{
  for i=1..len {
    sum_elements(a[i], b[i], result[i]);
  }
}

sub main() 
{
    df a, b, result;
    ...
    cf с: sum_vectors(a, b, result, 3);
    ...
}
```

```
...
void c_sum_elements(int a, int b, OutputDF &result) {
  result.setValue(a + b);
}
...
```

В итоге, в `result[1]`, `result[2]`, `result[3]` будут лежать элементы итогового вектора.


**Инициализация с явным выделением памяти**
Согласитесь, что итерироваться каждый раз в LuNA, чтобы потом вызвать функцию суммирования на Си, неудобно. Хотелось бы не нагружать код лишними циклами, а сразу передавать векторы в си-функцию, которая сделает с их элементами всё, что необходимо для корректной работы программы.

Такое реализовать возможно, однако придется изменить инициализацию наших векторов.

```
import c_init(name, int, int) as init

sub initialize(name vector, int value, int len)
{
    init(vector, value, len);
}

sub main() 
{
    df a, b;
    cf a: initialize(a, 10, 3);
    cf b: initialize(b, 5, 3);
}
```

```
#include "ucenv.h"
#include <cstdio>

extern "C" {

void c_init(OutputDF &df, int val, int len) {
    int *vec = df.create<int>(len);
    for (int i = 0; i < len; i++) {
        vec[i] = val;
    }
}
```

Здесь метод `create<T>()` выделит на куче память для некоторого числа, определяемого `len`, элементов типа `Т`. 

Дальнейшее суммирование реализовать несложно.

```
import c_sum_vecs(value, value, name, int) as sum_vecs;
...
sub sum_vectors(name a, name b, name result, int len) 
{
    cf c: sum_vecs(a[j], b[j], result[j], 3);
}
...
```

```
...
void c_sum_vecs(const InputDF &a, 
                const InputDF &b, 
                OutputDF &result, int len) {

  int *res = result.create<int>(len);
  const int *f = a.getData<int>();
  const int *s = b.getData<int>();

  for (int i = 0; i < len; i++) {
    res[i] = f[i] + s[i];
  }
}
...
```

Здесь метод `getData` возвращает указатель на тип, переданный в треугольных скобках. В нашем случае мы получаем указатель на вектор, созданный нами в функции `init`.